<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/resources/favicon/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/resources/favicon/favicon.png">
  <link rel="mask-icon" href="/resources/favicon/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xxwywzy.github.io","root":"/","images":"/resources/img/","scheme":"Gemini","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本篇博客是《数据密集型应用系统设计》一书的学习笔记（第三章）。">
<meta property="og:type" content="article">
<meta property="og:title" content="《数据密集型应用系统设计》读书笔记（三）">
<meta property="og:url" content="https://xxwywzy.github.io/2021/12/20/dda-3/">
<meta property="og:site_name" content="口仆">
<meta property="og:description" content="本篇博客是《数据密集型应用系统设计》一书的学习笔记（第三章）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-09-07-094440.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-12-20-025329.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-09-07-103635.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-09-08-084117.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-12-20-025506.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-10-26-035254.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-11-01-080434.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-11-23-120704.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-11-23-122540.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-11-23-123616.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-11-26-073056.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-11-26-073644.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-12-06-043931.png">
<meta property="og:image" content="http://media.zjubiomedit.com/2021-12-06-122244.png">
<meta property="article:published_time" content="2021-12-20T11:07:06.000Z">
<meta property="article:modified_time" content="2023-08-07T07:28:40.000Z">
<meta property="article:author" content="Zheyu Wang">
<meta property="article:tag" content="大数据">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://media.zjubiomedit.com/2021-09-07-094440.png">


<link rel="canonical" href="https://xxwywzy.github.io/2021/12/20/dda-3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xxwywzy.github.io/2021/12/20/dda-3/","path":"2021/12/20/dda-3/","title":"《数据密集型应用系统设计》读书笔记（三）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《数据密集型应用系统设计》读书笔记（三） | 口仆</title>
  











<link rel="stylesheet" href="/resources/fonts/longcang/longcang-regular.css" >
<link rel="stylesheet" href="/resources/fonts/lxgw/lxgwwenkailite-regular.css" >
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">口仆</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Long may the sunshine</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-culture"><a href="/culture/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>MEME</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据库核心：数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">1.1.</span> <span class="nav-text">哈希索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stable-%E5%92%8C-lsm-tree"><span class="nav-number">1.2.</span> <span class="nav-text">STable 和 LSM-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sstable-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">SSTable 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%92%8C%E7%BB%B4%E6%8A%A4-sstable"><span class="nav-number">1.2.2.</span> <span class="nav-text">构建和维护 SSTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.3.</span> <span class="nav-text">性能优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#b-tree"><span class="nav-number">1.3.</span> <span class="nav-text">B-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF-b-tree-%E5%8F%AF%E9%9D%A0"><span class="nav-number">1.3.1.</span> <span class="nav-text">使 B-tree 可靠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-b-tree"><span class="nav-number">1.3.2.</span> <span class="nav-text">优化 B-tree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-b-tree-%E5%92%8C-lsm-tree"><span class="nav-number">1.4.</span> <span class="nav-text">对比 B-Tree 和 LSM-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lsm-tree-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.4.1.</span> <span class="nav-text">LSM-tree 的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lsm-tree-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.4.2.</span> <span class="nav-text">LSM-tree 的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">其他索引结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%B4%A2%E5%BC%95%E4%B8%AD%E5%AD%98%E5%82%A8%E5%80%BC"><span class="nav-number">1.5.1.</span> <span class="nav-text">在索引中存储值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95"><span class="nav-number">1.5.2.</span> <span class="nav-text">多列索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%92%8C%E6%A8%A1%E7%B3%8A%E7%B4%A2%E5%BC%95"><span class="nav-number">1.5.3.</span> <span class="nav-text">全文搜索和模糊索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E4%BF%9D%E5%AD%98%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9"><span class="nav-number">1.5.4.</span> <span class="nav-text">在内存中保存所有内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">事务处理与分析处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93"><span class="nav-number">2.1.</span> <span class="nav-text">数据仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%9F%E5%9E%8B%E4%B8%8E%E9%9B%AA%E8%8A%B1%E5%9E%8B%E5%88%86%E6%9E%90%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">星型与雪花型分析模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">3.</span> <span class="nav-text">列式存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%8E%8B%E7%BC%A9"><span class="nav-number">3.1.</span> <span class="nav-text">列压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text">列存储中的排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text">列存储的写操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8E%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="nav-number">3.4.</span> <span class="nav-text">聚合：数据立方体与物化视图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">思维导图</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zheyu Wang"
      src="/resources/favicon/avatar.png">
  <p class="site-author-name" itemprop="name">Zheyu Wang</p>
  <div class="site-description" itemprop="description">相信过程</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xxwywzy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xxwywzy" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/xxwywzy" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;xxwywzy" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/xxwywzy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;xxwywzy" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/xxwywzy" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;xxwywzy" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xxwywzy.github.io/2021/12/20/dda-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/resources/favicon/avatar.png">
      <meta itemprop="name" content="Zheyu Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="口仆">
      <meta itemprop="description" content="相信过程">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《数据密集型应用系统设计》读书笔记（三） | 口仆">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《数据密集型应用系统设计》读书笔记（三）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-20 19:07:06" itemprop="dateCreated datePublished" datetime="2021-12-20T19:07:06+08:00">2021-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">编程与算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>39 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><div class="note danger"><p>本篇博客是《数据密集型应用系统设计》一书的学习笔记（第三章）。</p>
</div>
<span id="more"></span>
<p>本篇笔记对应原书第三章：<strong>数据存储与检索</strong>。</p>
<p>从最基本的层面来看，数据库只需要做两件事情：</p>
<ol type="1">
<li>当给出数据时对数据进行存储</li>
<li>当查询数据时对数据进行返回</li>
</ol>
<p>上一章讨论了数据模型与查询语言，即向数据库给出数据时数据的格式以及数据查询的机制，其可以理解为从应用开发者的角度出发讨论了上述两件事情。本章将从<strong>数据库</strong>的角度来进行讨论，即如何存储给出的数据以及如何在要求查询时找到所需的数据，所介绍的存储引擎可以用于传统的关系数据库和大多数 NoSQL 数据库。</p>
<h1 id="数据库核心数据结构">数据库核心：数据结构</h1>
<p>首先介绍一个世界上最简单的数据库，其通过两个 Bash 函数实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">db_set () &#123;</span><br><span class="line">    echo &quot;$1,$2&quot; &gt;&gt; database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db_get () &#123;</span><br><span class="line">    grep &quot;^$1,&quot; database | sed -e &quot;s/^$1,//&quot; | tail -n 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数实现了一个 key-value 存储。当调用 <code>db_set key value</code> 时，它将在数据库中保存所输入的 <code>key</code> 和 <code>value</code>；然后，调用 <code>db_get key</code>，它会查找与输入 <code>key</code> 相关联的最新值并返回。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ db_set 123456 <span class="string">&#x27;&#123;&quot;name&quot;:&quot;London&quot;,&quot;attractions&quot;:[&quot;Big Ben&quot;,&quot;London Eye&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">$ db_set 42 <span class="string">&#x27;&#123;&quot;name&quot;:&quot;San Francisco&quot;,&quot;attractions&quot;:[&quot;Golden Gate Bridge&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">$ db_set 42 <span class="string">&#x27;&#123;&quot;name&quot;:&quot;San Francisco&quot;,&quot;attractions&quot;:[&quot;Exploratorium&quot;]&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">$ db_get 42</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;San Francisco&quot;</span>,<span class="string">&quot;attractions&quot;</span>:[<span class="string">&quot;Exploratorium&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> database</span><br><span class="line">123456,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;London&quot;</span>,<span class="string">&quot;attractions&quot;</span>:[<span class="string">&quot;Big Ben&quot;</span>,<span class="string">&quot;London Eye&quot;</span>]&#125;</span><br><span class="line">42,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;San Francisco&quot;</span>,<span class="string">&quot;attractions&quot;</span>:[<span class="string">&quot;Golden Gate Bridge&quot;</span>]&#125;</span><br><span class="line">42,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;San Francisco&quot;</span>,<span class="string">&quot;attractions&quot;</span>:[<span class="string">&quot;Exploratorium&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>该数据库的底层存储格式非常简单：一个<strong>纯文本</strong>文件，其中每行包含一个 <code>key-value</code> 对，用逗号分隔（与 CSV 文件类似，忽略转义问题）。每次调用 <code>db_set</code> 文件将追加新内容到文件末尾，即便多次更新某个键，旧版本的值也不会被覆盖，而是需要查看文件中<strong>最后一次</strong>出现的键来找到最新的值（在 <code>db_get</code> 中使用了 <code>tail -n 1</code>）。</p>
<p>追加文件尾部方式的<strong>优点</strong>在于其非常高效，使得 <code>db_set</code> 函数的性能很好。当前许多数据库内部都使用了与这种方式的基本原理相同的<strong>日志</strong>（log），其是一个仅支持追加式更新的数据文件。另一方面，这种方式的<strong>缺点</strong>在于，如果日志文件保存了大量的记录，那么 <code>db_get</code> 函数的性能会非常差，每一次查询都需要从头到尾扫描整个数据库文件。</p>
<p>为了高效地查找数据库中特定键的值，我们需要一种新的数据结构：<strong>索引</strong>（index）。索引的基本想法是保留一些额外的元数据，这些元数据作为路标，帮助定位想要的数据。很多数据库允许单独添加和删除索引，而不影响数据库的内容。然而，维护额外的结构势必会引入开销，特别是在新数据写入时。我们需要在读和写之间进行<strong>权衡</strong>：适当的索引可以加速读取查询，但是每个索引都会减慢写速度。默认情况下，数据库通常不会对所有内容进行索引，需要开发人员基于对应用程序典型查询模式的了解，来手动选择索引，以在为应用程序提供最有利加速的同时，避免引入过多不必要的开销。</p>
<h2 id="哈希索引">哈希索引</h2>
<p>键-值数据是一种常见的数据类型，其与大多数编程语言内置的字典结构相似，而字典通常采用<strong>哈希表</strong>（hash map or hash table，本节不作区分）来实现。对于这种类型的数据，我们可以考虑基于哈希表来构建索引，即<strong>哈希索引</strong>。</p>
<p>假定数据存储全部采用追加式文件组成，那么一种可行的索引方式是：在内存中保存一个 hash map，把每个键一一映射到数据文件中特定的字节偏移量，以便找到每个值的位置，如下图所示：</p>
<p><img src="http://media.zjubiomedit.com/2021-09-07-094440.png" width=70%/></p>
<p>每当在文件中追加新的 key-value 对时，需要更新 hash map 来反映刚刚写入数据的偏移量（包括插入新的键与更新已有的键）。当查找某个值时，使用 hash map 来找到文件中的偏移量，即存储位置，然后读取其内容。</p>
<p>上述方法虽然简单，但确实可行，并且能够实现较高性能的读和写，只要所有的 key 可以放入内存（key-value 类型一般不涉及额外的索引，也就没有权衡问题）。对于 value 数据，则可以超过内存大小，存放在磁盘中，并且能够通过缓存等方式来减少磁盘 I/O。</p>
<p>对于追加文件的存储方式，还需要考虑的一个问题是如何避免用尽<strong>磁盘空间</strong>。一种较好的解决方案是将日志分解成一定大小的<strong>片段</strong>（segments），当片段达到指定大小时就关闭它，并将后续写入到新的片段文件中。然后，在这些片段上进行<strong>压缩</strong>（compaction），丢弃日志中重复的键，只保留每个键最近的更新，如下图所示：</p>
<p><img src="http://media.zjubiomedit.com/2021-12-20-025329.png" width=70%/></p>
<p>此外，由于压缩往往使得片段变得更小，也可以在执行压缩的同时将多个片段合并在一起，如下图所示。由于片段在写入后不可修改（只会追加），所以合并后的片段会被写入另一个新的文件。对于这些冻结段（已达到指定大小）的合并与压缩过程可以在后台线程中完成，且在运行时，仍然可以使用旧的片段文件执行读取请求（写请求在新的片段中）。在合并完成后，将读取请求切换到新的合并片段上，并将旧的片段删除。</p>
<p><img src="http://media.zjubiomedit.com/2021-09-07-103635.png" width=70%/></p>
<p>每个片段中都有自己的内存哈希表，将键映射到文件的偏移量。为了找到键的值，首先检查最新片段的哈希表，如果键不存在，则检查第二新的片段，以此类推。由于合并过程可以维持较少的片段数量，查找通常不需要检查很多的哈希表。</p>
<p>以上就是对哈希索引的简单介绍。在哈希索引的实际实现（例如 Bitcask）中，还需要考虑以下这些重要问题：</p>
<ul>
<li><strong>文件格式</strong>：在上面的案例中，使用 CSV 作为日志的格式。实际上，更快更简单的方法是使用二进制格式，以字节为单位来记录字符串的长度，并在之后跟上原始字符串（不需要转义）。</li>
<li><strong>删除记录</strong>：如果要删除键和它关联的值，则需要在数据文件中追加一个特殊的删除记录（因为无法修改），该记录有时也被称为墓碑标记（tombstone）。当合并日志片段时，墓碑标记会告知合并过程丢弃这个已删除键的所有值。</li>
<li><strong>崩溃恢复</strong>：如果数据库重新启动，则内存中的哈希表会丢失。原则上，可以通过从头到尾读取整个片段文件，记录每个键的最新值的偏移量，来恢复每个片段的哈希表。为了加快恢复速度，可以考虑将每个片段的哈希表快照存储在磁盘上，以便更快的加载到内存中。</li>
<li><strong>部分写入的记录</strong>：由于数据库随时可能崩溃，需要在将记录追加到日志的时候设置校验值，以便于发现损坏部分并丢弃。</li>
<li><strong>并发控制</strong>：由于写入以严格的先后顺序追加到日志中，通常的实现选择是只有一个写线程。数据文件片段是不可变的（仅支持追加），可以被多个线程同时读取（不用担心出现读取结果不一致的情况）。</li>
</ul>
<p>总的来看，以追加式设计为核心的哈希索引具有写入速度快、并发与崩溃恢复简单等优点，但也存在着内存限制、区间查询效率低等局限性。</p>
<h2 id="stable-和-lsm-tree">STable 和 LSM-Tree</h2>
<h3 id="sstable-简介">SSTable 简介</h3>
<p>在上一节介绍的原始哈希索引中，键值对按照写入顺序排列，对于同一个键，后出现的值优于之前的值。除此之外，文件中的键值对顺序并不重要。现在，我们将简单地改变片段文件的形式：要求键值对<strong>按照键进行排序</strong>，这种格式被称为<strong>排序字符串表</strong>（Sorted String Table，SSTable），其要求每个键在每个合并的片段文件中只出现一次（压缩过程已经确保了这一点）。与原始哈希索引的日志片段相比，SSTable 的优点主要体现在以下三个方面：</p>
<ol type="1">
<li><p><strong>合并片段更加简单高效</strong>。对于 SSTable，其段落的合并类似于归并排序算法，如下图所示。端到端地并发读取多个输入片段文件，比较每个文件中的第一个键，将最小的键拷贝到输出文件，并不断重复上述过程，以产生一个新的按键排序的合并片段文件（对于相同键保留最新段的值）。这种方法对于文件大于可用内存的情况也能够处理（并非一次性读取整个文件）。</p>
<p><img src="http://media.zjubiomedit.com/2021-09-08-084117.png" alt="image-20210908164103968" width=60%/></p></li>
<li><p><strong>不再需要在内存中保存所有键的索引</strong>。由于键是按顺序存储的，所以在文件中查找特定的键时，可以直接跳到该键前某个键的偏移，从那里开始扫描，而无需遍历所有键。如下图所示，handiwork 键一定位于 handbag 和 handsome 之间。因此，所构建的内存索引可以是稀疏的，只需要记录某些键的偏移量。定位到离目标键最近的键后，直接在片段文件中进行扫描即可。</p>
<p><img src="http://media.zjubiomedit.com/2021-12-20-025506.png" width=60%/></p></li>
<li><p><strong>可以对记录进行压缩存储以节省空间</strong>。由于查询请求需要扫描一定范围内的多个键值对，我们可以考虑将这些记录保存到一个块中，并在写磁盘之间将其进行压缩（如上图所示，此处的压缩为使用特定的压缩算法如 Snappy 进行压缩，注意与合并过程中的压缩区分），然后稀疏内存索引的每个条目指向压缩块的开头。除了节省磁盘空间外，这种压缩还减少了 I/O 带宽的占用。</p></li>
</ol>
<h3 id="构建和维护-sstable">构建和维护 SSTable</h3>
<p>了解了 SSTable 的基本工作原理后，考虑到写入可能以任意顺序出现，我们需要一种方法来让数据能够依照键进行排序。虽然在磁盘上维护排序结构是可行的，不过在内存中进行要更加容易。内存排序有很多广为人知的树状数据结构，例如红黑树或 AVL 树。使用这些数据结构，可以按任意顺序插入键并以排序后的顺序读取它们。</p>
<p>具体来说，基于 SSTable 的存储引擎的基本工作流程如下：</p>
<ul>
<li>当写入数据时，将其添加到内存中的平衡树结构中（如红黑树）。这个内存中的树有时被称为<strong>内存表</strong>（memtable）。</li>
<li>当内存表大于某个阈值（通常为几兆字节）时，将其作为 SSTable 文件写入磁盘。由于树已经维护了排序后的键值对，所以写入会比较高效。新的 SSTable 文件将会称为数据库的最新片段。当 SSTable 写入磁盘的同时，写入可以继续添加到一个新的内存表实例。</li>
<li>为了处理读取请求，首先会尝试在内存表中查找键，然后是最新的磁盘片段，接下来是次新的磁盘片段，以此类推，直到找到目标。</li>
<li>后台进程会周期性地执行合并与压缩过程，以合并多个片段文件，并丢弃那些已被覆盖或删除的值，同时节省磁盘空间。</li>
</ul>
<p>上述方案可以很好地工作，但也存在一个问题：如果数据库崩溃，那么最近的写入（在内存表中但尚未写入磁盘）将会丢失。为了避免该问题，可以在磁盘上保留单独的日志，每个写入都会立即追加到该日志。该日志不需要按键排序，其唯一目的是在崩溃后恢复内存表。每当将内存表写入 SSTable 时，相应的日志可以被丢弃。</p>
<p>基于上述算法构建的存储引擎被用在包括 LevelDB、RocksDB、Cassandra、HBase 等数据库中。最初这种索引结构由 Patrick O'Neil 等人命名为<strong>日志结构的合并树</strong>（LSM-Tree），现在将基于合并和压缩排序文件原理的存储引擎统称为 LSM 存储引擎。</p>
<h3 id="性能优化">性能优化</h3>
<p>在进行存储引擎的实际实现时，还有很多细节值得深入优化。例如，当查找数据库中某个不存在的键时，LSM-Tree 算法需要先检查内存表，再一直回溯访问到最旧的片段文件，导致速度非常慢。为了优化这种访问，存储引擎常常使用额外的<strong>布隆过滤器</strong>（bloom filters）。布隆过滤器是一种内存高效的数据结构，用以近似计算集合的内容，能够很快地知道数据库中是否存在某个键。</p>
<p>此外，对于 SSTable 的压缩合并的具体顺序与时机，最常见的方式是<strong>大小分级</strong>（size-tiered）和<strong>分层压缩</strong>（leveled compaction）。在大小分级的压缩中，较新与较小的 SSTable 被连续合并到较旧和较大的 SSTable 中；在分层压缩中，键的范围分裂成多个更小的 SSTables，旧数据被移动到单独的”层级“，这样压缩可以逐步进行并使用更少的磁盘空间。在上一小节提到的数据库中，LevelDB 与 RocksDB 使用分层压缩，HBase 使用大小分级，而 Cassandra 则同时支持这两种压缩。</p>
<p>总的来说，即使有很多细微的差异，但 LSM-tree 的基本思想——<strong>保存在后台合并的一系列 SSTable</strong>——是非常简单且有效的。即便数据集远远大于可用内存，它仍然能够正常工作。由于数据按排序存储，我们可以高效地执行区间查询，且序列性的磁盘写入可以支持非常高的写入吞吐量。</p>
<h2 id="b-tree">B-Tree</h2>
<p>除了上述讨论的日志结构索引，实际上，目前最常见且广泛使用的一种索引类型是 <strong>B-tree</strong>。与 SSTable 一样，B-tree 保留按键排序的键值对，以实现高效的 key-value 查找和区间查询，但是其本质上有着非常不同的设计理念。</p>
<p>不同于日志结构索引将数据库分解为可变大小的段（一般几兆字节或更大），B-tree 将数据库分解成<strong>固定大小</strong>的块或页（一般为 4 KB），页是内部读/写的最小单元，每个页面都可以使用地址或位置进行标识，这样可以让一个页面引用另一个页面，类似指针。我们可以使用这些页面引用来构造一个<strong>树状页面</strong>，如下图所示：</p>
<p><img src="http://media.zjubiomedit.com/2021-10-26-035254.png" width=70%></p>
<p>某一页会被指定为 B-tree 的<strong>根</strong>（root），当查找索引中的一个键时，总是从这里开始。该页面包含若干个键和对子页的引用，每个子页都负责一系列连续范围内的键，相邻引用之间的键可以指示这些范围之间的边界。B-tree 中一个页所包含的子页的引用数量称为<strong>分支因子</strong>（branching factor），上图中的分支因子为 6，实际情况下分支因子的大小取决于存储页面引用和范围边界所需的空间总量，通常为几百个。</p>
<p>如果需要更新 B-tree 中<strong>现有键的值</strong>，首先应搜索包含该键的叶子页，更改该页的值，并将页写回到磁盘；如果需要添加<strong>新键</strong>，则需要找到其范围包含新键的页，并将其添加到该页，如果页中没有足够的空间来容纳新键，则将其分裂为两个半满的页，并且父页也需要更新以包含分裂之后的新的键范围，如下图所示：</p>
<p><img src="http://media.zjubiomedit.com/2021-11-01-080434.png" width=75%></p>
<p>上述算法可以确保树保持<strong>平衡</strong>：具有 <span class="math inline">\(n\)</span> 个键的 B-tree 总是具有 <span class="math inline">\(O(\log n)\)</span> 的深度。大多数数据库可以构建 3-4 层的 B-tree，不需要遍历非常深的页面引用即可找到所需的页（分支因子为 500 的 4 KB 页的四级树可以存储高达 256 TB）。</p>
<h3 id="使-b-tree-可靠">使 B-tree 可靠</h3>
<p>对于 B-tree 来说，其底层的写操作是使用新数据来<strong>覆盖</strong>磁盘上的旧页，假定覆盖不会改变页的磁盘存储位置，对该页的所有引用保持不变。与之相比，日志结构索引（如 LSM-tree）仅追加更新文件（并删除过时文件），但不会修改文件。</p>
<p>在硬件层面上，对于磁性硬盘驱动器，覆盖操作意味着将磁头移动到正确的位置，然后旋转盘面，最后用新的数据覆盖相应的扇区；而对于 SSD，由于 SSD 必须一次擦除并重写非常大的存储芯片块，情况会更加复杂。</p>
<p>由于覆盖操作的复杂性，其有时会带来较大的风险。一方面，某些操作需要覆盖多个不同的页，如果数据库在完成部分页写入之后发生崩溃，最终会导致索引被破坏。为了防止上述情况发生，常见的 B-tree 实现需要包括一个磁盘上的额外数据结构：<strong>预写日志</strong>（write-ahead log，WAL），这是一个仅支持追加修改的文件，每个 B-tree 的修改必须先更新 WAL 然后再修改树本身的页。当数据库崩溃后需要修复时，该日志用于将 B-tree 恢复到一致的状态。</p>
<p>另一方面，如果多个线程要同时访问 B-tree，原地更新页需要注意并发控制，以防止线程可能会看到树处于不一致的状态。通常可以使用<strong>锁存器</strong>（latches），即轻量级的锁来保护树的数据结构。与之相比，日志结构索引在后台执行所有合并，并不会干扰前端的查询，并且会不时地用新段原子性地替换旧段。</p>
<h3 id="优化-b-tree">优化 B-tree</h3>
<p>下面列举一些针对 B-tree 的优化措施：</p>
<ul>
<li>某些数据库（例如 LMDB）不使用覆盖页和维护 WAL 来进行崩溃恢复，而是使用写时复制方案，修改的页被写入不同的位置</li>
<li>保存键的缩略信息以节省页空间，只需要提供足够的信息来描述键的起止范围</li>
<li>许多 B-tree 的实现尝试对树进行布局，以便相邻叶子页可以按顺序保存在磁盘上，提升读取效率</li>
<li>添加额外的指针到树中，如每个叶子页面可能会向左和向右引用其同级的兄弟页，这样可以避免跳回父页</li>
<li>借鉴日志结构的想法来减少磁盘寻道（<strong>分形树</strong>）</li>
</ul>
<h2 id="对比-b-tree-和-lsm-tree">对比 B-Tree 和 LSM-Tree</h2>
<p>虽然 B-tree 的实现比 LSM-tree 更成熟，但是由于 LSM-tree 的性能优点，其所代表的日志结构索引正越来越受欢迎。根据经验，LSM-tree 通常对于写入更快，而 B-tree 被认为对于读取更快，下面将简要地描述 LSM-tree 与 B-tree 相比的优缺点。</p>
<h3 id="lsm-tree-的优点">LSM-tree 的优点</h3>
<p>对于 B-tree 索引来说，一次写操作必须至少写两次数据：一次写入预写日志，一次写入树的页本身；而日志结构索引由于反复压缩和 SSTable 的合并，也会重写数据多次。这种一次数据库写入请求导致的多次磁盘写被称为<strong>写放大</strong>（write amplification）。对于大量写密集的应用程序，写放大具有直接的性能成本。</p>
<p>一般来说，LSM-tree 有时具有<strong>较低的写放大</strong>，能够承受比 B-tree 更高的写入吞吐量。部分原因在于它们以顺序方式写入紧凑的 SSTable 文件，而不必重写树中的多个页。</p>
<p>另一方面，LSM-tree 可以支持更好的压缩，通常磁盘上的文件比 B-tree 小很多。由于页的碎片化，B-tree 存储引擎有时会使某些磁盘空间无法使用，而 LSM-tree 不是面向页的，且定期重写 SSTable 以消除碎片化。综合以上几点，LSM-tree 相比 B-tree 具有<strong>较低的存储开销</strong>。</p>
<h3 id="lsm-tree-的缺点">LSM-tree 的缺点</h3>
<p>日志结构索引的缺点主要体现在压缩过程有时会干扰正在进行的读写操作。一方面，由于磁盘的并发资源有限，当执行昂贵的压缩操作时，很容易发生读写请求等待的情况；另一方面，在高写入吞吐量时，磁盘的有限写入带宽需要在的初始写入和后台运行的压缩线程之间所共享，可能发生压缩无法匹配新数据写入速率的情况，导致读取速度的降低（需要检查更多的段文件）。</p>
<p>相比之下，B-tree 的优点在于每个键都恰好唯一对应于索引中的某个位置，而日志结构的存储引擎可能在不同段中具有相同键的多个副本，这一优点可以为 B-tree 带来更强大的事务语义。</p>
<p>总的来看，虽然日志结构索引越来越受欢迎，但是对于具体的应用场景，还是需要<strong>实地测试</strong>来决定哪种存储引擎更加适合。</p>
<h2 id="其他索引结构">其他索引结构</h2>
<p>上述讨论的索引都是 key-value 索引，其作用类似于关系模型中的<strong>主键</strong>（primary key）索引，主键唯一标识关系表中的一行，或文档数据库中的一个文档，或图形数据库中的一个顶点。数据库中的其他记录可以通过其主键来引用该行/文档/顶点，主键索引用于解析此类引用。</p>
<p>与主键索引相呼应，<strong>二级索引</strong>（secondary index）也很常见，其通常对于高效地执行联结操作十分重要。在关系数据库中，我们可以在同一个表上创建多个二级索引。二级索引可以较容易地基于 key-value 索引来构建，区别在于它的键不是唯一的，这可以通过两种方式解决：</p>
<ul>
<li>使索引中的每个值成为匹配行标识符的列表</li>
<li>追加一些行标识符来使每个键变得唯一</li>
</ul>
<p>无论使用哪种方式，B-tree 和日志结构索引都可以用作二级索引。实际上，除了这两种常见的索引结构，还有一些其他的索引结构，下面将对这些索引结构进行简要的介绍。</p>
<h3 id="在索引中存储值">在索引中存储值</h3>
<p>索引中的键是查询搜索的对象，而值可以是以下两类之一：</p>
<ul>
<li>实际的行（文档、顶点）</li>
<li>对其他地方存储的行的引用</li>
</ul>
<p>对于第二种情况，存储行的具体位置被称为<strong>堆文件</strong>（heap file），它不以特定的顺序存储数据（可以是追加式或覆盖式），当存在多个二级索引时，可以避免复制数据。如果采用覆盖式更新，对方法在更新值而不更改键时会非常高效，只要新值的字节数不大于旧值，记录就可以直接覆盖。</p>
<p>对于第一种情况，有时从索引到堆文件的额外跳转会带来较大的读取性能损失，这时我们希望将索引行直接存储在索引中，这被称为<strong>聚集索引</strong>（clustered index）。例如，在 MySQL InnoDB 存储引擎中，表的主键始终是聚集索引，二级索引引用主键位置。PS: 索引还是保存在磁盘中的，需要查询时再加载到内存里。</p>
<p>聚集索引和非聚集索引之中有一种折中设计，称为<strong>覆盖索引</strong>（covering index）或<strong>包含列的索引</strong>（index with included columns），它在索引中保存一些表的列值，可以支持只通过索引即可回答某些简单查询。</p>
<p>总的来看，聚集和覆盖索引可以加快读取速度，但是它们需要额外的存储，并且会增加写入的开销。此外，数据库还需要更多的工作来保证事务性，以防止应用程序因为数据冗余而得到不一致的结果。</p>
<h3 id="多列索引">多列索引</h3>
<p>目前为止讨论的索引只将一个键映射到一个值，如果需要同时查询表的多个列，则无法满足要求，需要构建多列索引。</p>
<p>最常见的多列索引类型称为<strong>级联索引</strong>（concatenated index），它通过将一列追加到另一列，将几个字段简单地组合成一个键（索引的定义指定字段连接的顺序）。需要注意，索引的查找会严格遵循字段的连接顺序（可以单独查第一个字段，但不能单独查第二个字段）。</p>
<p>更普遍的一次查询多列的方法是多维索引。以地理空间数据为例，当用户在地图上查找地点时，需要进行一个包含经度和纬度的二维范围查询，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> restaurants <span class="keyword">WHERE</span> latitude <span class="operator">&gt;</span> <span class="number">51.4946</span> <span class="keyword">AND</span> latitude <span class="operator">&lt;</span> <span class="number">51.5079</span> </span><br><span class="line">                            <span class="keyword">AND</span> longitude <span class="operator">&gt;</span> <span class="number">-0.1162</span> <span class="keyword">AND</span> longitude <span class="operator">&lt;</span> <span class="number">-0.1004</span>;</span><br></pre></td></tr></table></figure>
<p>标准的 B-tree 或 LSM-tree 无法高效地应对这种查询，只能分次进行。一种优化方法是使用空格填充曲线将二维位置转换为单个数字，然后使用常规的 B-tree 索引；另一种更常见的方法是使用专门的空间索引，如 R 树，此处不作展开。</p>
<h3 id="全文搜索和模糊索引">全文搜索和模糊索引</h3>
<p>目前为止讨论的索引都假定具有确切的数值，并允许查询键的确切值或排序后的键的取值范围。在某些场景下，我们需要进行模糊搜索，仅搜索类似的键，例如拼写错误的单词。实现这种模糊查询需要不同的技术。在全文搜索中，通常支持对一个单词的所有同义词进行查询，并忽略单词语法上的变体，Lucene（一种全文搜索引擎工具包）支持在某个编辑距离内搜索文本，其对词典使用类似 SSTable 的结构，内存中的索引是键中的字符序列的有限状态自动机，支持在给定编辑距离内高效地搜索单词。</p>
<p>此外，其他模糊搜索技术则沿着文档分类和机器学习的方向发展，更多细节需参考信息检索方面的文献。</p>
<h3 id="在内存中保存所有内容">在内存中保存所有内容</h3>
<p>目前为止讨论的数据结构都是为了适应磁盘限制。与内存相比，磁盘更难以处理，如果要获得良好的读写性能，需要精心安排磁盘上的数据布局。随着内存变得更便宜，其成本逐渐降低，且许多数据集并没有那么大，可以将它们完全保留在内存中，这推动了<strong>内存数据库</strong>（in-memory databases）的发展。</p>
<p>对于某些内存数据库来说，内存中的 key-value 存储仅用于缓存（例如 Memcached），其接受机器重启造成的数据丢失。而对于其他内存数据库来说，其旨在实现<strong>持久性</strong>，例如可以通过特殊硬件、或将更改记录写入磁盘，或将定期快照写入磁盘，以及复制内存中的状态到其他机器等方式来实现。当内存数据库重启时，需要基于持久性的实现媒介来重新载入其状态。</p>
<p>在实际产品上，诸如 VoltDB、MemSQL 和 Oracle TimesTen 都是具有关系模型的内存数据库，通过移除与管理磁盘数据结构相关的开销，这些数据库可以获得极大的性能提升。RAMCloud 是一个开源的、具有持久性的内存 key-value 存储（使用日志结构），而 Redis 和 Couchbase 则通过异步写入磁盘提供较弱的持久性。</p>
<p>与直觉相反，内存数据库的性能优势并不是因为它们不需要从磁盘读取（在足够内存下基于磁盘的存储引擎也可能不需要读取），而是因为它们避免了使用写磁盘的格式对内存数据结构编码的开销。此外，内存数据库还提供了基于磁盘索引难以实现的某些数据模型，例如 Redis 为各种数据结构（如优先级队列和集合）都提供了类似数据库的访问接口。</p>
<p>最近的研究表明，内存数据库架构还可以扩展到支持远大于内存的数据集，而不会导致以磁盘为中心架构的开销。这种所谓的<strong>反缓存</strong>（anti-caching）方法，当没有足够的内存时，通过将最近最少使用的数据从内存写到磁盘，并在将来再次被访问时将其加载到内存。这种方法与操作系统对虚拟内存和交换文件的操作类似，但是可以在记录级别而不是整个内存页的粒度工作。不过，这种方法仍然需要索引完全放入内存。</p>
<h1 id="事务处理与分析处理">事务处理与分析处理</h1>
<p>在商业数据处理的早期阶段，写入数据库通常对应于商业交易场景。尽管目前数据库已经扩展到了各种领域，但<strong>事务</strong>（transaction）一词仍然存在，主要指一个逻辑单元的一组读写操作。事务不一定具有 ACID （原子性、一致性、隔离性和持久性）属性，只是意味着允许客户端进行低延迟读取和写入。进一步地，尽管处理数据的种类不同，数据库的基本访问方式仍然与处理业务交易类似，通常使用索引中的某些键查找少量记录，根据用户的输入插入或更新记录，这种基于交互式应用的访问模式被称为<strong>在线事务处理</strong>（OLTP）。</p>
<p>另一方面，数据库也开始越来越多地用于<strong>数据分析</strong>。数据分析具有非常不同的访问模式：分析查询通常需要扫描大量记录，每条记录只读取少数几列，并计算汇总统计信息，而不是返回原始数据给用户。这些查询通常由业务分析师编写，称之为<strong>在线分析处理</strong>（OLAP）。OLTP 和 OLAP 之间的区别有时并不那么明确，下表对它们的一些经典特征进行了总结：</p>
<p><img src="http://media.zjubiomedit.com/2021-11-23-120704.png" width=85%></p>
<p>最初，相同的数据库可以同时用于事务处理与分析查询，例如 SQL 可以同时胜任 OLTP 和 OLAP 类型的查询。然而，自 20 世纪 80 年代后期以来，很多公司放弃使用 OLTP 系统用于分析目的，而是在单独的数据库上进行分析，这个单独的数据库被称为<strong>数据仓库</strong>（data warehouse）。</p>
<h2 id="数据仓库">数据仓库</h2>
<p><strong>数据仓库</strong>是一种独立于 OLTP 系统之外的数据库，可以帮助分析人员在不影响 OLTP 操作的情况下进行分析，其通常包括所有各种 OLTP 系统的只读副本。从 OLTP 数据库中提取数据（使用周期性数据转储或连续更新流），转换为分析友好的模式，执行必要的清理，然后加载到数据仓库中，这种将数据导入数据仓库的过程称为<strong>提取-转换-加载</strong>（ETL），如下图所示：</p>
<p><img src="http://media.zjubiomedit.com/2021-11-23-122540.png" width=75%></p>
<p>使用单独的数据仓库而不是直接查询 OLTP 系统进行分析，一个优势在于数据仓库可以针对分析访问模式进行优化。事实证明，本章前半部分讨论的索引算法适合 OLTP，但不擅长应对分析查询。数据仓库的数据模型最常见的是关系型，虽然其和关系型 OLTP 表面上都具有 SQL 查询接口，但是系统内部针对迥然不同的查询模式进行了各自优化。</p>
<p>许多数据库供应商现在专注于支持事务处理或分析工作负载，但不能同时支持两者。事务处理与数据仓库越来越称为两个独立的存储和查询引擎。此外，除了成熟的商业数据仓库系统，还出现了大量开源的基于 Hadoop 的 SQL 项目，包括 Apache Hive、Spark SQL、Cloudera Impala、Facebook Presto、Apache Tajo 和 Apache Drill，其中一些系统基于 Google Dremel 而构建。</p>
<h2 id="星型与雪花型分析模式">星型与雪花型分析模式</h2>
<p>根据不同的应用需求，事务处理领域广泛使用了多种不同的数据模型（见第 2 章），而分析型业务的数据模型则要少得多，许多数据仓库都相当公式化地使用了<strong>星型模式</strong>（star schema），也被称为<strong>维度建模</strong>（dimensional modeling）。该模式基于关系型数据库实现。</p>
<p>如下图所示，星型模式的中心是一个所谓的<strong>事实表</strong>（fact table），图中对应为 <code>fact_sales</code> 表。事实表的每一行表示在特定时间发生的事件（图中每一行表示客户购买的一个产品）。通常，事实被捕获为独立的事件，使得之后的分析具有最大的灵活性，这也意味着事实表可能会变得非常庞大。</p>
<p>事实表中的部分列是属性，例如产品销售的价格，供应商的成本等，而其他列可能会引用其他表的外键，称为<strong>维度表</strong>（dimension tables），维度通常代表事件的对象（who）、内容（what）、地点（where）、时间（when）、方法（how）以及原因（why）。</p>
<p><img src="http://media.zjubiomedit.com/2021-11-23-123616.png" width=70%/></p>
<p>星型模式的一个变体被称为<strong>雪花模式</strong>（snowflake schema），其中维度进一步细分为子空间。雪花模式比星型模式更规范化，但是星型模式通常是首选，主要是因为对于分析人员，星型模式使用起来更简单。</p>
<h1 id="列式存储">列式存储</h1>
<p>如果事实表中有数以万亿行、PB 大小的数据，高效地存储与查询这些数据将成为一个具有挑战性的问题，相比之下维度表通常小得多，因此本节将主要关注事实表的存储。实际上，虽然事实表通常超过 100 列，但典型的数据仓库查询往往一次只访问其中的 4 或 5 个，如下例所示（结果只需返回三列）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  dim_date.weekday, dim_product.category,</span><br><span class="line">  <span class="built_in">SUM</span>(fact_sales.quantity) <span class="keyword">AS</span> quantity_sold</span><br><span class="line"><span class="keyword">FROM</span> fact_sales</span><br><span class="line">    <span class="keyword">JOIN</span> dim_date <span class="keyword">ON</span> fact_sales.date_key <span class="operator">=</span> dim_date.date_key</span><br><span class="line">    <span class="keyword">JOIN</span> dim_product <span class="keyword">ON</span> fact_sales.product_sk <span class="operator">=</span> dim_product.product_sk</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    dim_date.year <span class="operator">=</span> <span class="number">2013</span> <span class="keyword">AND</span></span><br><span class="line">    dim_product.category <span class="keyword">IN</span> (<span class="string">&#x27;Fresh fruit&#x27;</span>, <span class="string">&#x27;Candy&#x27;</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    dim_date.weekday, dim_product.category;</span><br></pre></td></tr></table></figure>
<p>对于大多数 OLTP 数据库（无论是关系模型还是文档模型），存储以面向行的方式布局：来自表的一行的所有值彼此相邻存储。对于上述查询，即使为特定键构建索引，仍然需要将所有行从磁盘加载到内存中（对于非内存数据库），进行解析并过滤出不符合所选条件的行，这样的操作较为消耗时间与空间。</p>
<p>为了应对上述问题，<strong>面向列存储</strong>（column-oriented storage）的想法被提出：不要将一行中的所有值存储在一起，而是将每列中的所有值存储在一起。如果每个列存储在一个单独的文件中，查询只需要读取和解析在该查询中使用的那些列。如下图所示：</p>
<p><img src="http://media.zjubiomedit.com/2021-11-26-073056.png" width=70%/></p>
<p>列存储在关系数据模型中最容易理解，但它同样适用于非关系数据。需要注意，面向列的存储布局依赖一组列文件，每个文件以相同顺序保存着数据行。</p>
<h2 id="列压缩">列压缩</h2>
<p>除了仅从磁盘中加载查询所需的列之外，还可以通过压缩数据来进一步降低对磁盘吞吐量的要求。对于列中不同的数据模式，可以采用不同的压缩技术，在数据仓库中特别有效的一种技术是<strong>位图编码</strong>（bitmap encoding），如下图所示：</p>
<p><img src="http://media.zjubiomedit.com/2021-11-26-073644.png" width=70%/></p>
<p>通常，列中不同值的数量小于行数，我们可以将一个包含 <span class="math inline">\(n\)</span> 个不同值的列转化为 <span class="math inline">\(n\)</span> 个单独的位图，每个位图对应一个不同的值，其中的一个位对应为一行，如果行具有该值，则该位为 1，否则为 0（相当于把一列具体数值变成了一坨仅包含 0 或 1 的文件）。基于位图索引，我们可以方便地使用<strong>按位</strong>与或计算等方式来进行查询条件的执行。</p>
<p>另一方面，如果 <code>n</code> 非常小，上述这种每行对应一位的存储方式可能会包含很多 0（即较为稀疏），我们可以改为<strong>游程编码</strong>（run-length encoding）的方式，如上图的下半部分所示。</p>
<p>此外，除了减少需要从磁盘加载的数据量之外，面向列的存储布局也有利于高效利用 CPU 周期与内存带宽。列压缩使得列中更多的行可以加载到 L1 缓存，按位运算符可以直接对这样的列压缩数据块进行操作，这种技术被称为<strong>矢量化处理</strong>（vectorized processing）。</p>
<h2 id="列存储中的排序">列存储中的排序</h2>
<p>在列存储中，行的存储顺序并不太重要，但是需要一次排序整行，以保证可以正确维护列与列之间的关系。数据库管理员可以基于常见查询的知识来选择要排序表的列，以提升查询的速度。当第一列排序出现相同值时，可以指定第二列继续进行排序。</p>
<p>排序的另一个优点在于，它可以帮助进一步压缩列。如果主排序列上没有很多的值，那么在排序之后，其将出现一个非常长的序列，其中相同的值在一行中会连续重复多次，我们可以通过一个简单的游程编码，将一个包含数十亿行的表其压缩到几千字节。一般来说，基于第一个排序键的压缩效果通常最好，第二个和第三个排序键会使情况更加负载，也通常不会有太多相邻的重复值。</p>
<p>另一方面，C-Store 提出了一种列存储的改进方式：同时存储不同方式排序的冗余数据，以便在处理查询时，可以选择最适合特定查询模式的排序版本。对于列存储来说，这与面向行存储中的多个二级索引类似，最大的区别在于，面向行的存储将每一行都保存在一个位置（在堆文件或聚集索引中），二级索引只包含匹配行的指针；而对于列存储，通常没有任何指向别处数据的指针，只有包含值的列。</p>
<h2 id="列存储的写操作">列存储的写操作</h2>
<p>面向列存储的缺点在于写入较为困难，类似 B-tree 使用的原地更新方式，对于压缩的列是不可能的，因为各行是由它们在列中的位置标识的，因此插入操作必须一致地更新所有列。</p>
<p>一种较好的列存储写入方案是参考 LSM-tree。所有的写入首先进入内存出处区，将其添加到已排序的结构中，接着再准备写入磁盘。内存中的存储可以是面向行或面向列（不重要），当积累了足够的写入时，它们将与磁盘上的列文件合并，并批量写入新文件。</p>
<p>执行查询时，需要检查磁盘上的列数据和内存中最近的写入，并结合这两者，而查询优化器可以对用户隐藏这些内部细节。</p>
<h2 id="聚合数据立方体与物化视图">聚合：数据立方体与物化视图</h2>
<p>数据仓库的另一个值得一提的是<strong>物化聚合</strong>（materialized aggregates）。如前所述，数据仓库查询通常涉及各种聚合函数，如果许多不同查询使用相同的聚合，每次都处理原始数据将非常浪费，我们可以通过缓存查询最常适用的一些技术或总和，以减少查询时间。</p>
<p>创建这种缓存的一种方式是<strong>物化视图</strong>（materialized view）。与关系数据模型中的标准（模拟）视图不同，物化视图是查询结果的实际副本，并被写入到磁盘，而虚拟视图只是用于编写查询的快捷方式。当底层数据发生变化时，物化视图也需要随之更新，这种更新方式对于数据写入性能会有所影响，因此其通常对于大量读密集的数据仓库更有意义，在 OLTP 数据库中则不经常使用。</p>
<p>物化视图常见的一种特殊情况称为<strong>数据立方体</strong>（data cube）或 <strong>OLAP 立方体</strong>，它是由不同维度分组的聚合网格，如下图所示：</p>
<p><img src="http://media.zjubiomedit.com/2021-12-06-043931.png" width=70%></p>
<p>上图给出的例子包含了两个维度表的外键，每个轴代表一个维度，每个单元格即为不同维度组合的所有事实的属性，沿着每一行或列应用聚合操作，即可得到一个减少一个维度的总和。</p>
<p>物化数据立方体的优点在于某些查询会非常快，因为它们已经被预先计算出来；缺点则是缺乏像查询原始数据那样的灵活性。因此，大多数数据仓库都保留尽可能多的原始数据，仅当数据立方体可以对特定查询显著提升性能时，才会采用多维数据聚合。</p>
<h1 id="小结">小结</h1>
<p>本章节简单介绍了数据库内部处理<strong>存储</strong>与<strong>检索</strong>的底层原理。概括来讲，存储引擎分为两大类：针对事务处理（OLTP）优化的架构，以及针对分析型（OLAP）的优化架构，它们典型的访问方式存在较大差异：</p>
<ul>
<li><strong>OLTP 系统</strong>通常面向用户，可能收到大量的请求。为了处理负载，应用程序通常在每个查询中只涉及少量的记录。应用程序基于某类键来请求记录，而存储引擎使用索引来查找所请求键的数据，磁盘寻道时间往往是瓶颈。</li>
<li><strong>OLAP 系统</strong>（以数据仓库为代表）主要由业务分析师使用，处理的查询请求数目远低于 OLTP 系统，但每个查询通常要求非常苛刻，需要在短时间内扫描数百万条记录，磁盘带宽（而非寻道时间）通常是瓶颈，而面向列的存储对于这种工作负载逐渐成为流行的解决方案。</li>
</ul>
<p>在 OLTP 方面，有两个主要流派的存储引擎：</p>
<ul>
<li><strong>日志结构流派</strong>。只允许追加式更新文件和删除过时的文件，但不会修改已写入的文件。BitCask、SSTables、LSM-tree、LevelDB、Cassandra、HBase、Lucene 等属于此类。</li>
<li><strong>原地更新流派</strong>。将磁盘视为可以覆盖的一组固定大小的页，B-tree 是这一哲学的最典型代表，它已用于所有主要的关系数据库，以及大量的非关系数据库。</li>
</ul>
<p>日志结构的存储引擎是一个相对较新的方案，其关键思想是系统地将磁盘上随机访问转为顺序写入，由于硬盘驱动器和 SSD 的功能特性，可以实现更高的写入吞吐量。此外，还有一些更复杂的索引结构，以及为全内存而以优化的数据库。</p>
<p>作为应用开发人员，掌握更多有关存储引擎内部的知识，可以更好地了解哪种工具最适合你的具体应用。如果还需要进一步调整数据库的可调参数，这些理解还可以帮助开发者正确评估调高或调低参数所带来的影响。</p>
<h1 id="思维导图">思维导图</h1>
<p><img src="http://media.zjubiomedit.com/2021-12-06-122244.png" width=70%/></p>

    </div>

    
    
    

    <footer class="post-footer">




<div class="license">
  <div class="license-title">《数据密集型应用系统设计》读书笔记（三）</div>
  <div class="license-link">
    <a href="https://xxwywzy.github.io/2021/12/20/dda-3/">https://xxwywzy.github.io/2021/12/20/dda-3/</a>
  </div>
  <div class="license-meta">
    <div class="license-meta-item">
      <div class="license-meta-title">本文作者</div>
      <div class="license-meta-text">
          Zheyu Wang
      </div>
    </div>
      <div class="license-meta-item">
        <div class="license-meta-title">发布于</div>
        <div class="license-meta-text">
          2021-12-20
        </div>
      </div>
      <div class="license-meta-item">
        <div class="license-meta-title">更新于</div>
        <div class="license-meta-text">
          2023-08-07
        </div>
      </div>
    <div class="license-meta-item">
      <div class="license-meta-title">许可协议</div>
      <div class="license-meta-text">
          <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank">CC BY-NC-SA 4.0</a>
      </div>
    </div>
  </div>
  <div class="license-statement">
      转载或引用本文时，请遵守上述许可协议，注明出处、不得用于商业用途！
  </div>
</div>
          <div class="post-tags">
              <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag"># 大数据</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/25/deep-1/" rel="prev" title="deeplearning.ai 第一部分：神经网络与深度学习">
                  <i class="fa fa-angle-left"></i> deeplearning.ai 第一部分：神经网络与深度学习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/05/cg-1/" rel="next" title="《计算机图形学基础》读书笔记（一）">
                  《计算机图形学基础》读书笔记（一） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81ODgyNi8zNTI4OA=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zheyu Wang</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">332k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">18:26</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="/js/third-party/comments/livere.js"></script>



  <style>
    #taboola-livere { display: none;}
  </style>



<script type="text/javascript">
var linkLists = document.querySelectorAll(".link-list");

linkLists.forEach(function(linkList) {
  var listPath = linkList.getAttribute('json-src');
  var iconPath = linkList.getAttribute('icon-src');
  
  var xhr = new XMLHttpRequest();
  xhr.open('GET', listPath, true);
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
      var data = JSON.parse(xhr.responseText);
      
      var li = "";
      linkList.innerHTML = '';

      for (var infoIndex = 0; infoIndex < data.length; infoIndex++) {
        var info = data[infoIndex];
        var labelWarn = info['warn'] ? '<span class="label warn">' + info['warn'] + '</span>' : '';
        var labelInfo = info['info'] ? '<span class="label info">' + info['info'] + '</span>' : '';

        li += '<div class="link-list-container">';
        li += '<img class="link-list-image" src="' + iconPath + info['logo'] + '">';
        li += '<p>' + info['title'] + labelInfo + labelWarn + '</p>';
        li += '<p>' + info['intro'] + '</p>';
        li += '<a href="' + info['url'] + '" rel="noopener" target="_blank" data-pjax-state=""></a>';
        li += '</div>';
      }
      
      linkList.innerHTML = li;
    }
  };
  xhr.send();
});
</script>


<script type="text/javascript">
var cultureList = document.querySelectorAll(".culture-list");
if (cultureList.length !== 0) {
  var j = -1;
  for (var i = 0; i < cultureList.length; i++) {
    const listPath = cultureList[i].getAttribute('json-src');
    const coverPath = cultureList[i].getAttribute('cover-src');
    
    var xhr = new XMLHttpRequest();
    xhr.open('GET', listPath, true);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4 && xhr.status === 200) {
        j++;
        var data = JSON.parse(xhr.responseText);
        var li = "";
        
        cultureList[j].innerHTML = '';

        for (var infoIndex = 0; infoIndex < data.length; infoIndex++) {
          var info = data[infoIndex];
          
          var title = info['title'];
          if (info['link']) {
            title = '<a href="' + info['link'] + '">' + info['title'] + '</a>';
          }

          var author = info['author'] ? '<span class="author">' + info['author'] + '</span>' : '';

          var intro = info['intro'] ? info['intro'] : '';

          var star = '';
          if (info['score'] == null) {
            star = '';
          } else {
            var colorStar = '';
            var greyStar = '';
            var int = Math.floor(info['score']); //整数部分
            var fract = 0;
            if (info['score'] % 1 !== 0) {
              fract = 1;
            }
            for (var m = 0; m < int; m++) {
              colorStar += '★';
            }
            if (fract !== 0) {
              colorStar += '☆';
            }
            for (var m = 0; m < (5 - fract - int); m++) {
              greyStar += '☆';
            }
            if (info['score'] !== 5) {
              star = '<span class="star-score">' + colorStar + '<span class="grey-star">' + greyStar + '</span></span>';
            } else {
              star = '<span class="star-score">' + colorStar + '</span>';
            }
          }

          li += '<div class="media">';
          li += '<div class="media-cover" style="background-image:url(' + coverPath + info['cover'] + ')"></div>';
          li += '<div class="media-meta">';
          li += '<div class="media-meta-item title">' + title + '</div>';
          li += '<div class="media-meta-item">' + author + star + '</div>';
          li += '<div class="media-meta-item intro">' + intro + '</div>';
          li += '</div></div>';
        }
        
        cultureList[j].innerHTML = li;
      }
    };
    xhr.send();
  }
}
</script>




<script src="/resources/minigrid.min.js"></script>
<script type="text/javascript">
var album = document.querySelector(".album");
if (album) {
  // 相册列表 JSON 数据
  var imgDataPath = album.getAttribute('json-src');
  // 照片存储路径
  var imgPath = album.getAttribute('photo-src');
  // 最多显示数量
  var imgMaxNum = 50;
  // 获取窗口大小以决定图片宽度
  var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
  var imageWidth;

  if (windowWidth < 768) {
    imageWidth = 145; // 移动端图片宽度
  } else {
    imageWidth = 235;
  }

  // 腾讯云自定义样式 (数据万象外网流量需要付费)
  //var imgStyle = '!' + imageWidth + 'x';
  //var imgStyle = '!300x';

  // 生成相册
  var linkDataPath = imgDataPath;
  var photo = {
    page: 1,
    offset: imgMaxNum,
    init: function () {
      var that = this;
      var xhr = new XMLHttpRequest();
      xhr.open("GET", linkDataPath, true);
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          var data = JSON.parse(xhr.responseText);
          that.render(that.page, data);
        }
      };
      xhr.send();
    },
    render: function (page, data) {
      var begin = (page - 1) * this.offset;
      var end = page * this.offset;
      if (begin >= data.length) return;
      var imgNameWithPattern, imgName, imageSize, imageX, imageY, li = "";
      for (var i = begin; i < end && i < data.length; i++) {
        imgNameWithPattern = data[i].split(' ')[1];
        imgName = imgNameWithPattern.split('.')[0];
        imageSize = data[i].split(' ')[0];
        imageX = imageSize.split('.')[0];
        imageY = imageSize.split('.')[1];
        li += '<div class="card" style="width:' + imageWidth + 'px" >';
        li += '<div class="album-photo" style="height:'+ imageWidth * imageY / imageX + 'px">';
        li += '<a class="fancybox fancybox.image" href="' + imgPath + imgNameWithPattern + '" itemscope="" itemtype="http://schema.org/ImageObject" itemprop="url" data-fancybox="group" rel="group" data-caption="' + imgName + '" title="' +  imgName + '">';
        li += '<img data-src="' + imgPath + imgNameWithPattern + '" src="' + imgPath + imgNameWithPattern + '" alt="' +  imgName + '" data-loaded="true">';
        li += '</a>';
        li += '</div>';
        li += '</div>';
      }
      album.insertAdjacentHTML('beforeend', li);
      this.minigrid();
    },
    minigrid: function () {
      var grid = new Minigrid({
        container: '.album',
        item: '.card',
        gutter: 12
      });
      grid.mount();
      window.addEventListener('resize', function () {
        grid.mount();
      });
    }
  };
  photo.init();
}
</script>
</body>
</html>
